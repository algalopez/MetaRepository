<head>
    <link rel="stylesheet" type="text/css" href="style_container.css">
</head>
<body>
<div class="container">
    <h2>RECURSION</h2>
    <div class="subindex">
        <p>
            The way to iterate in pure functional languages<br>
        </p>
        <ul>
            <li><a href="#recursion">Recursion</a><br></li>
            <li><a href="#tailRecursion">Tail recursion</a><br></li>
            <li><a href="#example">Other example</a><br></li>
        </ul>   
    </div>
    <div id="recursion">
        <h3>RECURSION</h3>
        <div class="example">
            <p> 
                Example: Factorial using recursion
            </p>
            <code>
                <pre>
                    factorial1 :: (Integral a) => a -> a
                    factorial1 0 = 1
                    factorial1 n = n * factorial1 (n - 1)
                </pre>
            </code>
        </div>
    </div>
    <div id="tailRecursion">
        <h3>TAIL RECURSION</h3>
        In some languages, the compiler can optimize the stack consumption when tail recursion is used<br>
        The same stack frame can be reused, since there are no hanging operations left in the function<br>
        Thatâ€™s why an accumulator was needed in the tailFact function; it eliminates having to multiply after the recursive call<br>
        <div class="example">
            <p> 
                Example: Factorial using tail recursion
            </p>
            <code>
                <pre>
                    factorial2 :: (Eq t, Num t) => t -> t
                    factorial2 x = tailFactorial x 1
                      where tailFactorial 0 acc = acc
                            tailFactorial n acc = tailFactorial (n - 1) (n * acc)
                </pre>
            </code>
        </div>
    </div>
    <div id="example">
        <h3>OTHER EXAMPLE</h3>
        <div class="example">
            <p> 
                Example: Binary search
            </p>
            <code>
                <pre>
                    // initially called with low = 0, high = N-1
                    BinarySearch(A[0..N-1], value, low, high) {
                        // invariants: value > A[i] for all i < low
                                       value < A[i] for all i > high
                        if (high < low)
                            return not_found // value would be inserted at index "low"
                        mid = (low + high) / 2
                        if (A[mid] > value)
                            return BinarySearch(A, value, low, mid-1)
                        else if (A[mid] < value)
                            return BinarySearch(A, value, mid+1, high)
                        else
                            return mid
                    }
                </pre>
            </code>
        </div>
    </div>
</div>
</body>
